const Clutter = imports.gi.Clutter;
const Backgrounds = imports.backgrounds;
const Utils = imports.utils;

let Parser = ometa {
  spacesNoNl = (~'\n' space)*,

  styleName = (~']' anything)+:n -> n.join(''),

  background = 'camera'                                   -> ['background', new Backgrounds.Camera()]
             | styleName:n ?Utils.isMimeType(n, 'image/') -> ['background', new Backgrounds.Image(n)]
             | styleName:n ?Utils.isMimeType(n, 'video/') -> ['background', new Backgrounds.Video(n)],

  styleValue = "=" (~']' anything)+:v                                           -> v.join(''),
  style = "duration":k styleValue:v                                             -> [k, parseFloat(v)]
        | "text-color":k styleValue:v                                           -> [k, Utils.colorFromString(v)]
        | "text-alignment":k styleValue:v                                       -> [k, Utils.textAlignment(v)]
        | styleName:c ?Utils.isValidColor(c)                                    -> ['background-color', Utils.colorFromString(c)]
        | spaces <letter (letter | digit | '-')+>:s ?Utils.isGravity(s) spaces  -> ['gravity', Utils.getGravity(s)]
        | spaces <letter (letter | digit | '-')+>:s ?Parser.isKeyword(s) spaces -> [s, true]
        | spaces <letter (letter | digit | '-')+>:k styleValue:v                -> [k, v],

  property = '[' (style | background):p ']' -> p,
  headerProperty :d = spacesNoNl property:p appendProperty(d, p),
  slideProperty :s = spacesNoNl property:p appendProperty(s, p),

  comment = fromTo('#', '\n'):s        -> s.slice(1),
  content = ((~('\n' | '-''-') anything)*:s '\n') -> (s.join('') + '\n'),

  slideContent :s = (comment:cmt appendComment(s, cmt) |
                     content:cnt appendContent(s, cnt))+ -> s,

  slide = newSlide():s
          '-''-' spacesNoNl slideProperty(s)* spacesNoNl '\n'
          slideContent(s) -> s,

  shell = '#''!' (~space anything)* (~'\n' anything)* '\n'
        | empty,

  document = newDocument():d shell (headerProperty(d) | space+)* slide+:sds end -> { properties: d.properties, slides: sds }
};


Parser._keywords = {
  "fill": true,
  "no-markup": true,
};
Parser.isKeyword = function(str) {
  return this._keywords.hasOwnProperty(str);
};

Parser.newDocument = function() {
  return { properties: {},
           slides: [], };
};

Parser.newSlide = function() {
  return { comments: [],
           content: [],
           properties: {}, };
};
Parser.appendComment = function(slide, comment) {
  slide.comments.push(comment);
};
Parser.appendContent = function(slide, content) {
  slide.content.push(content);
};
Parser.appendProperty = function(container, tuple) {
  container.properties[tuple[0]] = tuple[1];
};

let parse = function(str) {
  let indexToPosition = function(source, idx) {
    let linePos = 0, lineNum = 0;
    for (let i = 0; i < idx; i++) {
      if (source.charAt(i) == '\n') {
        linePos = i;
        lineNum++;
      }
    }
    return { line: lineNum + 1,
             offset: idx - linePos };
  };

  let document;
  try {
    document = Parser.matchAll(str, 'document');
    //log(JSON.stringify(document, null, 2));
  } catch (e) {
    let pos = indexToPosition(str, e.idx);
    log('Parsing error at : line ' + pos.line + ' offset ' + pos.offset);
    throw e;
  }
  return document;
};
